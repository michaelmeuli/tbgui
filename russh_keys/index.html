<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate contains methods to deal with SSH keys, as defined in crate Russh. This includes in particular various functions for opening key files, deciphering encrypted keys, and dealing with agents."><title>russh_keys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="russh_keys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../russh_keys/index.html">russh_<wbr>keys</a><span class="version">0.45.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>russh_keys</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/russh_keys/lib.rs.html#1-1397">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate contains methods to deal with SSH keys, as defined in
crate Russh. This includes in particular various functions for
opening key files, deciphering encrypted keys, and dealing with
agents.</p>
<p>The following example shows how to do all these in a single example:
start and SSH agent server, connect to it with a client, decipher
an encrypted private key (the password is <code>b"blabla"</code>), send it to
the agent, and ask the agent to sign a piece of data
(<code>b"Please sign this"</code>, below).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>russh_keys::<span class="kw-2">*</span>;
 <span class="kw">use </span>futures::Future;

 <span class="attr">#[derive(Clone)]
 </span><span class="kw">struct </span>X{}
 <span class="kw">impl </span>agent::server::Agent <span class="kw">for </span>X {
     <span class="kw">fn </span>confirm(<span class="self">self</span>, <span class="kw">_</span>: std::sync::Arc&lt;key::KeyPair&gt;) -&gt; Box&lt;<span class="kw">dyn </span>Future&lt;Output = (<span class="self">Self</span>, bool)&gt; + Send + Unpin&gt; {
         Box::new(futures::future::ready((<span class="self">self</span>, <span class="bool-val">true</span>)))
     }
 }

 <span class="kw">const </span>PKCS8_ENCRYPTED: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str = <span class="string">"-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIIFLTBXBgkqhkiG9w0BBQ0wSjApBgkqhkiG9w0BBQwwHAQITo1O0b8YrS0CAggA\nMAwGCCqGSIb3DQIJBQAwHQYJYIZIAWUDBAEqBBBtLH4T1KOfo1GGr7salhR8BIIE\n0KN9ednYwcTGSX3hg7fROhTw7JAJ1D4IdT1fsoGeNu2BFuIgF3cthGHe6S5zceI2\nMpkfwvHbsOlDFWMUIAb/VY8/iYxhNmd5J6NStMYRC9NC0fVzOmrJqE1wITqxtORx\nIkzqkgFUbaaiFFQPepsh5CvQfAgGEWV329SsTOKIgyTj97RxfZIKA+TR5J5g2dJY\nj346SvHhSxJ4Jc0asccgMb0HGh9UUDzDSql0OIdbnZW5KzYJPOx+aDqnpbz7UzY/\nP8N0w/pEiGmkdkNyvGsdttcjFpOWlLnLDhtLx8dDwi/sbEYHtpMzsYC9jPn3hnds\nTcotqjoSZ31O6rJD4z18FOQb4iZs3MohwEdDd9XKblTfYKM62aQJWH6cVQcg+1C7\njX9l2wmyK26Tkkl5Qg/qSfzrCveke5muZgZkFwL0GCcgPJ8RixSB4GOdSMa/hAMU\nkvFAtoV2GluIgmSe1pG5cNMhurxM1dPPf4WnD+9hkFFSsMkTAuxDZIdDk3FA8zof\nYhv0ZTfvT6V+vgH3Hv7Tqcxomy5Qr3tj5vvAqqDU6k7fC4FvkxDh2mG5ovWvc4Nb\nXv8sed0LGpYitIOMldu6650LoZAqJVv5N4cAA2Edqldf7S2Iz1QnA/usXkQd4tLa\nZ80+sDNv9eCVkfaJ6kOVLk/ghLdXWJYRLenfQZtVUXrPkaPpNXgD0dlaTN8KuvML\nUw/UGa+4ybnPsdVflI0YkJKbxouhp4iB4S5ACAwqHVmsH5GRnujf10qLoS7RjDAl\no/wSHxdT9BECp7TT8ID65u2mlJvH13iJbktPczGXt07nBiBse6OxsClfBtHkRLzE\nQF6UMEXsJnIIMRfrZQnduC8FUOkfPOSXc8r9SeZ3GhfbV/DmWZvFPCpjzKYPsM5+\nN8Bw/iZ7NIH4xzNOgwdp5BzjH9hRtCt4sUKVVlWfEDtTnkHNOusQGKu7HkBF87YZ\nRN/Nd3gvHob668JOcGchcOzcsqsgzhGMD8+G9T9oZkFCYtwUXQU2XjMN0R4VtQgZ\nrAxWyQau9xXMGyDC67gQ5xSn+oqMK0HmoW8jh2LG/cUowHFAkUxdzGadnjGhMOI2\nzwNJPIjF93eDF/+zW5E1l0iGdiYyHkJbWSvcCuvTwma9FIDB45vOh5mSR+YjjSM5\nnq3THSWNi7Cxqz12Q1+i9pz92T2myYKBBtu1WDh+2KOn5DUkfEadY5SsIu/Rb7ub\n5FBihk2RN3y/iZk+36I69HgGg1OElYjps3D+A9AjVby10zxxLAz8U28YqJZm4wA/\nT0HLxBiVw+rsHmLP79KvsT2+b4Diqih+VTXouPWC/W+lELYKSlqnJCat77IxgM9e\nYIhzD47OgWl33GJ/R10+RDoDvY4koYE+V5NLglEhbwjloo9Ryv5ywBJNS7mfXMsK\n/uf+l2AscZTZ1mhtL38efTQCIRjyFHc3V31DI0UdETADi+/Omz+bXu0D5VvX+7c6\nb1iVZKpJw8KUjzeUV8yOZhvGu3LrQbhkTPVYL555iP1KN0Eya88ra+FUKMwLgjYr\nJkUx4iad4dTsGPodwEP/Y9oX/Qk3ZQr+REZ8lg6IBoKKqqrQeBJ9gkm1jfKE6Xkc\nCog3JMeTrb3LiPHgN6gU2P30MRp6L1j1J/MtlOAr5rux\n-----END ENCRYPTED PRIVATE KEY-----\n"</span>;

 <span class="attr">#[cfg(unix)]
 </span><span class="kw">fn </span>main() {
    env_logger::try_init().unwrap_or(());
    <span class="kw">let </span>dir = tempdir::TempDir::new(<span class="string">"russh"</span>).unwrap();
    <span class="kw">let </span>agent_path = dir.path().join(<span class="string">"agent"</span>);

    <span class="kw">let </span><span class="kw-2">mut </span>core = tokio::runtime::Runtime::new().unwrap();
    <span class="kw">let </span>agent_path_ = agent_path.clone();
    <span class="comment">// Starting a server
    </span>core.spawn(<span class="kw">async move </span>{
        <span class="kw">let </span><span class="kw-2">mut </span>listener = tokio::net::UnixListener::bind(<span class="kw-2">&amp;</span>agent_path_)
            .unwrap();
        russh_keys::agent::server::serve(tokio_stream::wrappers::UnixListenerStream::new(listener), X {}).<span class="kw">await
    </span>});
    <span class="kw">let </span>key = decode_secret_key(PKCS8_ENCRYPTED, <span class="prelude-val">Some</span>(<span class="string">"blabla"</span>)).unwrap();
    <span class="kw">let </span>public = key.clone_public_key().unwrap();
    core.block_on(<span class="kw">async move </span>{
        <span class="kw">let </span>stream = tokio::net::UnixStream::connect(<span class="kw-2">&amp;</span>agent_path).<span class="kw">await</span><span class="question-mark">?</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>client = agent::client::AgentClient::connect(stream);
        client.add_identity(<span class="kw-2">&amp;</span>key, <span class="kw-2">&amp;</span>[agent::Constraint::KeyLifetime { seconds: <span class="number">60 </span>}]).<span class="kw">await</span><span class="question-mark">?</span>;
        client.request_identities().<span class="kw">await</span><span class="question-mark">?</span>;
        <span class="kw">let </span>buf = <span class="string">b"signed message"</span>;
        <span class="kw">let </span>sig = client.sign_request(<span class="kw-2">&amp;</span>public, russh_cryptovec::CryptoVec::from_slice(<span class="kw-2">&amp;</span>buf[..])).<span class="kw">await</span>.<span class="number">1</span>.unwrap();
        <span class="comment">// Here, `sig` is encoded in a format usable internally by the SSH protocol.
        </span><span class="prelude-val">Ok</span>::&lt;(), Error&gt;(())
    }).unwrap()
 }

 <span class="attr">#[cfg(not(unix))]
 </span><span class="kw">fn </span>main() {}
</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="agent/index.html" title="mod russh_keys::agent">agent</a></div><div class="desc docblock-short">A module to write SSH agent.</div></li><li><div class="item-name"><a class="mod" href="ec/index.html" title="mod russh_keys::ec">ec</a></div></li><li><div class="item-name"><a class="mod" href="encoding/index.html" title="mod russh_keys::encoding">encoding</a></div></li><li><div class="item-name"><a class="mod" href="key/index.html" title="mod russh_keys::key">key</a></div></li><li><div class="item-name"><a class="mod" href="openssh/index.html" title="mod russh_keys::openssh">openssh</a></div></li><li><div class="item-name"><a class="mod" href="pkcs5/index.html" title="mod russh_keys::pkcs5">pkcs5</a></div></li><li><div class="item-name"><a class="mod" href="pkcs8/index.html" title="mod russh_keys::pkcs8">pkcs8</a></div></li><li><div class="item-name"><a class="mod" href="protocol/index.html" title="mod russh_keys::protocol">protocol</a></div></li><li><div class="item-name"><a class="mod" href="signature/index.html" title="mod russh_keys::signature">signature</a></div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Encryption.html" title="enum russh_keys::Encryption">Encryption</a></div><div class="desc docblock-short">AES encryption key.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum russh_keys::Error">Error</a></div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.PublicKeyBase64.html" title="trait russh_keys::PublicKeyBase64">Public<wbr>KeyBase64</a></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.check_known_hosts.html" title="fn russh_keys::check_known_hosts">check_<wbr>known_<wbr>hosts</a></div><div class="desc docblock-short">Check whether the host is known, from its standard location.</div></li><li><div class="item-name"><a class="fn" href="fn.check_known_hosts_path.html" title="fn russh_keys::check_known_hosts_path">check_<wbr>known_<wbr>hosts_<wbr>path</a></div><div class="desc docblock-short">Check that a server key matches the one recorded in file <code>path</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.decode_openssh.html" title="fn russh_keys::decode_openssh">decode_<wbr>openssh</a></div><div class="desc docblock-short">Decode a secret key given in the OpenSSH format, deciphering it if
needed using the supplied password.</div></li><li><div class="item-name"><a class="fn" href="fn.decode_pkcs5.html" title="fn russh_keys::decode_pkcs5">decode_<wbr>pkcs5</a></div><div class="desc docblock-short">Decode a secret key in the PKCS#5 format, possibly deciphering it
using the supplied password.</div></li><li><div class="item-name"><a class="fn" href="fn.decode_secret_key.html" title="fn russh_keys::decode_secret_key">decode_<wbr>secret_<wbr>key</a></div><div class="desc docblock-short">Decode a secret key, possibly deciphering it with the supplied
password.</div></li><li><div class="item-name"><a class="fn" href="fn.encode_pkcs8_pem.html" title="fn russh_keys::encode_pkcs8_pem">encode_<wbr>pkcs8_<wbr>pem</a></div></li><li><div class="item-name"><a class="fn" href="fn.encode_pkcs8_pem_encrypted.html" title="fn russh_keys::encode_pkcs8_pem_encrypted">encode_<wbr>pkcs8_<wbr>pem_<wbr>encrypted</a></div></li><li><div class="item-name"><a class="fn" href="fn.known_host_keys.html" title="fn russh_keys::known_host_keys">known_<wbr>host_<wbr>keys</a></div><div class="desc docblock-short">Get the server key that matches the one recorded in the user’s known_hosts file.</div></li><li><div class="item-name"><a class="fn" href="fn.known_host_keys_path.html" title="fn russh_keys::known_host_keys_path">known_<wbr>host_<wbr>keys_<wbr>path</a></div><div class="desc docblock-short">Get the server key that matches the one recorded in <code>path</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.learn_known_hosts.html" title="fn russh_keys::learn_known_hosts">learn_<wbr>known_<wbr>hosts</a></div><div class="desc docblock-short">Record a host’s public key into the user’s known_hosts file.</div></li><li><div class="item-name"><a class="fn" href="fn.learn_known_hosts_path.html" title="fn russh_keys::learn_known_hosts_path">learn_<wbr>known_<wbr>hosts_<wbr>path</a></div><div class="desc docblock-short">Record a host’s public key into a nonstandard location.</div></li><li><div class="item-name"><a class="fn" href="fn.load_openssh_certificate.html" title="fn russh_keys::load_openssh_certificate">load_<wbr>openssh_<wbr>certificate</a></div><div class="desc docblock-short">Load a openssh certificate</div></li><li><div class="item-name"><a class="fn" href="fn.load_public_key.html" title="fn russh_keys::load_public_key">load_<wbr>public_<wbr>key</a></div><div class="desc docblock-short">Load a public key from a file. Ed25519, EC-DSA and RSA keys are supported.</div></li><li><div class="item-name"><a class="fn" href="fn.load_secret_key.html" title="fn russh_keys::load_secret_key">load_<wbr>secret_<wbr>key</a></div><div class="desc docblock-short">Load a secret key, deciphering it with the supplied password if necessary.</div></li><li><div class="item-name"><a class="fn" href="fn.parse_public_key_base64.html" title="fn russh_keys::parse_public_key_base64">parse_<wbr>public_<wbr>key_<wbr>base64</a></div><div class="desc docblock-short">Reads a public key from the standard encoding. In some cases, the
encoding is prefixed with a key type identifier and a space (such
as <code>ssh-ed25519 AAAAC3N...</code>).</div></li><li><div class="item-name"><a class="fn" href="fn.write_public_key_base64.html" title="fn russh_keys::write_public_key_base64">write_<wbr>public_<wbr>key_<wbr>base64</a></div><div class="desc docblock-short">Write a public key onto the provided <code>Write</code>, encoded in base-64.</div></li></ul></section></div></main></body></html>