<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Server and client SSH asynchronous library, based on tokio/futures."><title>russh - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="russh" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../russh/index.html">russh</a><span class="version">0.45.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#using-non-socket-io--writing-tunnels" title="Using non-socket IO / writing tunnels">Using non-socket IO / writing tunnels</a></li><li><a href="#the-ssh-protocol" title="The SSH protocol">The SSH protocol</a></li><li><a href="#design-principles" title="Design principles">Design principles</a></li><li><a href="#internal-details-of-the-event-loop" title="Internal details of the event loop">Internal details of the event loop</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>russh</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/russh/lib.rs.html#1-547">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Server and client SSH asynchronous library, based on tokio/futures.</p>
<p>The normal way to use this library, both for clients and for
servers, is by creating <em>handlers</em>, i.e. types that implement
<code>client::Handler</code> for clients and <code>server::Handler</code> for
servers.</p>
<ul>
<li><a href="client/index.html" title="mod russh::client">Writing SSH clients - the <code>russh::client</code> module</a></li>
<li><a href="server/index.html" title="mod russh::server">Writing SSH servers - the <code>russh::server</code> module</a></li>
</ul>
<h2 id="using-non-socket-io--writing-tunnels"><a class="doc-anchor" href="#using-non-socket-io--writing-tunnels">§</a>Using non-socket IO / writing tunnels</h2>
<p>The easy way to implement SSH tunnels, like <code>ProxyCommand</code> for
OpenSSH, is to use the <code>russh-config</code> crate, and use the
<code>Stream::tcp_connect</code> or <code>Stream::proxy_command</code> methods of that
crate. That crate is a very lightweight layer above Russh, only
implementing for external commands the traits used for sockets.</p>
<h2 id="the-ssh-protocol"><a class="doc-anchor" href="#the-ssh-protocol">§</a>The SSH protocol</h2>
<p>If we exclude the key exchange and authentication phases, handled
by Russh behind the scenes, the rest of the SSH protocol is
relatively simple: clients and servers open <em>channels</em>, which are
just integers used to handle multiple requests in parallel in a
single connection. Once a client has obtained a <code>ChannelId</code> by
calling one the many <code>channel_open_…</code> methods of
<code>client::Connection</code>, the client may send exec requests and data
to the server.</p>
<p>A simple client just asking the server to run one command will
usually start by calling
<code>client::Connection::channel_open_session</code>, then
<code>client::Connection::exec</code>, then possibly
<code>client::Connection::data</code> a number of times to send data to the
command’s standard input, and finally <code>Connection::channel_eof</code>
and <code>Connection::channel_close</code>.</p>
<h2 id="design-principles"><a class="doc-anchor" href="#design-principles">§</a>Design principles</h2>
<p>The main goal of this library is conciseness, and reduced size and
readability of the library’s code. Moreover, this library is split
between Russh, which implements the main logic of SSH clients
and servers, and Russh-keys, which implements calls to
cryptographic primitives.</p>
<p>One non-goal is to implement all possible cryptographic algorithms
published since the initial release of SSH. Technical debt is
easily acquired, and we would need a very strong reason to go
against this principle. If you are designing a system from
scratch, we urge you to consider recent cryptographic primitives
such as Ed25519 for public key cryptography, and Chacha20-Poly1305
for symmetric cryptography and MAC.</p>
<h2 id="internal-details-of-the-event-loop"><a class="doc-anchor" href="#internal-details-of-the-event-loop">§</a>Internal details of the event loop</h2>
<p>It might seem a little odd that the read/write methods for server
or client sessions often return neither <code>Result</code> nor
<code>Future</code>. This is because the data sent to the remote side is
buffered, because it needs to be encrypted first, and encryption
works on buffers, and for many algorithms, not in place.</p>
<p>Hence, the event loop keeps waiting for incoming packets, reacts
to them by calling the provided <code>Handler</code>, which fills some
buffers. If the buffers are non-empty, the event loop then sends
them to the socket, flushes the socket, empties the buffers and
starts again. In the special case of the server, unsollicited
messages sent through a <code>server::Handle</code> are processed when there
is no incoming packet to read.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.keys"><code>pub use <a class="mod" href="../russh_keys/index.html" title="mod russh_keys">russh_keys</a> as keys;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="cipher/index.html" title="mod russh::cipher">cipher</a></div><div class="desc docblock-short">Cipher names</div></li><li><div class="item-name"><a class="mod" href="client/index.html" title="mod russh::client">client</a></div><div class="desc docblock-short">Client side of this library.</div></li><li><div class="item-name"><a class="mod" href="compression/index.html" title="mod russh::compression">compression</a></div><div class="desc docblock-short">Compression algorithm names</div></li><li><div class="item-name"><a class="mod" href="kex/index.html" title="mod russh::kex">kex</a></div><div class="desc docblock-short">Key exchange algorithm names</div></li><li><div class="item-name"><a class="mod" href="mac/index.html" title="mod russh::mac">mac</a></div><div class="desc docblock-short">MAC algorithm names</div></li><li><div class="item-name"><a class="mod" href="server/index.html" title="mod russh::server">server</a></div><div class="desc docblock-short">Server side of this library.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Channel.html" title="struct russh::Channel">Channel</a></div><div class="desc docblock-short">A handle to a session channel.</div></li><li><div class="item-name"><a class="struct" href="struct.ChannelId.html" title="struct russh::ChannelId">Channel<wbr>Id</a></div><div class="desc docblock-short">The identifier of a channel.</div></li><li><div class="item-name"><a class="struct" href="struct.ChannelStream.html" title="struct russh::ChannelStream">Channel<wbr>Stream</a></div><div class="desc docblock-short">AsyncRead/AsyncWrite wrapper for SSH Channels</div></li><li><div class="item-name"><a class="struct" href="struct.CryptoVec.html" title="struct russh::CryptoVec">Crypto<wbr>Vec</a></div><div class="desc docblock-short">A buffer which zeroes its memory on <code>.clear()</code>, <code>.resize()</code> and
reallocations, to avoid copying secrets around.</div></li><li><div class="item-name"><a class="struct" href="struct.Limits.html" title="struct russh::Limits">Limits</a></div><div class="desc docblock-short">The number of bytes read/written, and the number of seconds before a key
re-exchange is requested.</div></li><li><div class="item-name"><a class="struct" href="struct.MethodSet.html" title="struct russh::MethodSet">Method<wbr>Set</a></div><div class="desc docblock-short">Set of authentication methods, represented by bit flags.</div></li><li><div class="item-name"><a class="struct" href="struct.Preferred.html" title="struct russh::Preferred">Preferred</a></div><div class="desc docblock-short">Lists of preferred algorithms. This is normally hard-coded into implementations.</div></li><li><div class="item-name"><a class="struct" href="struct.SendError.html" title="struct russh::SendError">Send<wbr>Error</a></div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AgentAuthError.html" title="enum russh::AgentAuthError">Agent<wbr>Auth<wbr>Error</a></div></li><li><div class="item-name"><a class="enum" href="enum.ChannelMsg.html" title="enum russh::ChannelMsg">Channel<wbr>Msg</a></div><div class="desc docblock-short">Possible messages that <a href="struct.Channel.html#method.wait" title="method russh::Channel::wait">Channel::wait</a> can receive.</div></li><li><div class="item-name"><a class="enum" href="enum.ChannelOpenFailure.html" title="enum russh::ChannelOpenFailure">Channel<wbr>Open<wbr>Failure</a></div><div class="desc docblock-short">Reason for not being able to open a channel.</div></li><li><div class="item-name"><a class="enum" href="enum.Disconnect.html" title="enum russh::Disconnect">Disconnect</a></div><div class="desc docblock-short">A reason for disconnection.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum russh::Error">Error</a></div></li><li><div class="item-name"><a class="enum" href="enum.Pty.html" title="enum russh::Pty">Pty</a></div><div class="desc docblock-short">Standard pseudo-terminal codes.</div></li><li><div class="item-name"><a class="enum" href="enum.Sig.html" title="enum russh::Sig">Sig</a></div><div class="desc docblock-short">The type of signals that can be sent to a remote process. If you
plan to use custom signals, read <a href="https://tools.ietf.org/html/rfc4254#section-6.10">the
RFC</a> to
understand the encoding.</div></li><li><div class="item-name"><a class="enum" href="enum.SshId.html" title="enum russh::SshId">SshId</a></div><div class="desc docblock-short">The SSH client/server identification string.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Signer.html" title="trait russh::Signer">Signer</a></div></li></ul></section></div></main></body></html>