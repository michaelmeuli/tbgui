<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Client side of this library."><title>russh::client - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="russh" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../russh/index.html">russh</a><span class="version">0.45.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module client</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#implementing-clients" title="Implementing clients">Implementing clients</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate russh</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">russh</a></span><h1>Module <span>client</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/russh/client/mod.rs.html#16-1722">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Client side of this library.</p>
<h2 id="implementing-clients"><a class="doc-anchor" href="#implementing-clients">§</a>Implementing clients</h2>
<p>Maybe surprisingly, the data types used by Russh to implement
clients are relatively more complicated than for servers. This is
mostly related to the fact that clients are generally used both in
a synchronous way (in the case of SSH, we can think of sending a
shell command), and asynchronously (because the server may send
unsollicited messages), and hence need to handle multiple
interfaces.</p>
<p>The <a href="struct.Session.html" title="struct russh::client::Session">Session</a> is passed to the <a href="trait.Handler.html" title="trait russh::client::Handler">Handler</a>
when the client receives data.</p>
<p>Check out the following examples:</p>
<ul>
<li><a href="https://github.com/warp-tech/russh/blob/main/russh/examples/client_exec_simple.rs">Client that connects to a server, runs a command and prints its output</a></li>
<li><a href="https://github.com/warp-tech/russh/blob/main/russh/examples/client_exec_interactive.rs">Client that connects to a server, runs a command in a PTY and provides interactive input/output</a></li>
<li><a href="https://github.com/warp-tech/russh/blob/main/russh/examples/sftp_client.rs">SFTP client (with <code>russh-sftp</code>)</a></li>
</ul>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct russh::client::Config">Config</a></div><div class="desc docblock-short">The configuration of clients.</div></li><li><div class="item-name"><a class="struct" href="struct.Handle.html" title="struct russh::client::Handle">Handle</a></div><div class="desc docblock-short">Handle to a session, used to send messages to a client outside of
the request/response cycle.</div></li><li><div class="item-name"><a class="struct" href="struct.Prompt.html" title="struct russh::client::Prompt">Prompt</a></div></li><li><div class="item-name"><a class="struct" href="struct.RemoteDisconnectInfo.html" title="struct russh::client::RemoteDisconnectInfo">Remote<wbr>Disconnect<wbr>Info</a></div></li><li><div class="item-name"><a class="struct" href="struct.Session.html" title="struct russh::client::Session">Session</a></div><div class="desc docblock-short">Actual client session’s state.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.DisconnectReason.html" title="enum russh::client::DisconnectReason">Disconnect<wbr>Reason</a></div></li><li><div class="item-name"><a class="enum" href="enum.KeyboardInteractiveAuthResponse.html" title="enum russh::client::KeyboardInteractiveAuthResponse">Keyboard<wbr>Interactive<wbr>Auth<wbr>Response</a></div></li><li><div class="item-name"><a class="enum" href="enum.Msg.html" title="enum russh::client::Msg">Msg</a></div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Handler.html" title="trait russh::client::Handler">Handler</a></div><div class="desc docblock-short">A client handler. Note that messages can be received from the
server at any time during a session.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.connect.html" title="fn russh::client::connect">connect</a></div><div class="desc docblock-short">Connect to a server at the address specified, using the <a href="trait.Handler.html" title="trait russh::client::Handler"><code>Handler</code></a>
(implemented by you) and <a href="struct.Config.html" title="struct russh::client::Config"><code>Config</code></a> specified. Returns a future that
resolves to a <a href="struct.Handle.html" title="struct russh::client::Handle"><code>Handle</code></a>. This handle can then be used to create channels,
which in turn can be used to tunnel TCP connections, request a PTY, execute
commands, etc. The future will resolve to an error if the connection fails.
This function creates a connection to the <code>addr</code> specified using a
<a href="../../tokio/net/tcp/stream/struct.TcpStream.html" title="struct tokio::net::tcp::stream::TcpStream"><code>tokio::net::TcpStream</code></a> and then calls <a href="fn.connect_stream.html" title="fn russh::client::connect_stream"><code>connect_stream</code></a> under the hood.</div></li><li><div class="item-name"><a class="fn" href="fn.connect_stream.html" title="fn russh::client::connect_stream">connect_<wbr>stream</a></div><div class="desc docblock-short">Connect a stream to a server. This stream must implement
<a href="../../tokio/io/async_read/trait.AsyncRead.html" title="trait tokio::io::async_read::AsyncRead"><code>tokio::io::AsyncRead</code></a> and <a href="../../tokio/io/async_write/trait.AsyncWrite.html" title="trait tokio::io::async_write::AsyncWrite"><code>tokio::io::AsyncWrite</code></a>, as well as <a href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin"><code>Unpin</code></a>
and <a href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Send.html" title="trait core::marker::Send"><code>Send</code></a>. Typically, you may prefer to use <a href="fn.connect.html" title="fn russh::client::connect"><code>connect</code></a>, which uses a
<a href="../../tokio/net/tcp/stream/struct.TcpStream.html" title="struct tokio::net::tcp::stream::TcpStream"><code>tokio::net::TcpStream</code></a> and then calls this function under the hood.</div></li></ul></section></div></main></body></html>