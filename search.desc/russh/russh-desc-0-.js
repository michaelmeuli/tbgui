searchState.loadedDescShard("russh", 0, "Server and client SSH asynchronous library, based on …\n(client only)\nA handle to a session channel.\nThe identifier of a channel.\nPossible messages that Channel::wait can receive.\nReason for not being able to open a channel.\nServer refused to open a channel.\nAsyncRead/AsyncWrite wrapper for SSH Channels\nConnection timeout.\nThe key file could not be parsed.\nA buffer which zeroes its memory on <code>.clear()</code>, <code>.resize()</code> and\nA reason for disconnection.\nDisconnected\n(client only)\n(server only)\n(server only)\n(server only)\nThe SSH <code>hostbased</code> method (certain hostnames are allowed by …\nConnection closed by the remote side.\nInactivity timeout.\nThe protocol is in an inconsistent state.\nIndex out of bounds.\nThe SSH <code>keyboard-interactive</code> method (answer to a …\nKeepalive timeout.\nError during key exchange.\nUnspecified problem with the beginning of key exchange.\nRemote key changed, this could mean a man-in-the-middle …\nThe number of bytes read/written, and the number of …\nSet of authentication methods, represented by bit flags.\nThe SSH <code>none</code> method (no authentication).\nMissing authentication method.\nNo common cipher.\nNo common compression algorithm.\nNo common key exchange algorithm.\nNo common signature algorithm.\nNo common MAC algorithm.\nNo home directory found when trying to learn new host key.\nThe client is not yet authenticated.\nThe SSH <code>password</code> method (plaintext passwords).\nThe SSH <code>publickey</code> method (sign a challenge sent by the …\nInvalid packet authentication code.\nExcessive packet size.\nLists of preferred algorithms. This is normally hard-coded …\nStandard pseudo-terminal codes.\nWhen sending the id, use this buffer as it is and do not …\n(client only)\n(client only)\n(client only)\n(client only)\n(client only)\nThe type of signals that can be sent to a remote process. …\n(client only)\nThe SSH client/server identification string.\nWhen sending the id, append RFC standard <code>\\r\\n</code>. Example: …\n(server only)\nUnknown algorithm name.\nUnknown server key.\nInvalid SSH version string.\n(server only)\n(client only)\nMessage received/sent on unopened channel.\nThe server provided a wrong signature.\n(server only)\nInform the server that we will accept agent forwarding …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nCipher names\nPreferred symmetric ciphers.\nClear this CryptoVec (retaining the memory).\nClient side of this library.\nRequest that the channel be closed.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nCompression algorithm names\nPreferred compression algorithms.\nWhether all set bits in a source flags value are also set …\nSend data to a channel.\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nExecute a remote program (will be passed to a shell). This …\nAppend a slice at the end of this CryptoVec.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nSend data to a channel. The number of bytes added to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nCreate a <code>CryptoVec</code> from a slice\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume the <code>Channel</code> to produce a bidirectionnal stream, …\nWhether all known bits in this flags value are set.\nReturns <code>true</code> if and only if this CryptoVec is empty.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nKey exchange algorithm names\nPreferred key exchange algorithms.\nPreferred host &amp; public key algorithms.\nRe-export of the <code>russh-keys</code> crate.\nLength of this <code>CryptoVec</code>.\nMAC algorithm names\nPreferred MAC algorithms.\nMake a reader for the <code>Channel</code> to receive <code>ChannelMsg::Data</code> …\nMake a reader for the <code>Channel</code> to receive <code>ChannelMsg::Data</code> …\nMake a writer for the <code>Channel</code> to send <code>ChannelMsg::Data</code> …\nMake a writer for the <code>Channel</code> to send <code>ChannelMsg::Data</code> or …\nCreates a new <code>CryptoVec</code>.\nCreate a new <code>Limits</code>, checking that the given bounds cannot …\nCreates a new <code>CryptoVec</code> with <code>n</code> zeros.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nAppend a new byte at the end of this CryptoVec.\nAppend a new u32, big endian-encoded, at the end of this …\nRead <code>n_bytes</code> from <code>r</code>, and append them at the end of this …\nRead a big endian-encoded u32 from this CryptoVec, with the\nThe intersection of a source flags value with the …\nRequest a pseudo-terminal with the given characteristics.\nRequest a remote shell.\nRequest the start of a subsystem with the given name.\nRequest X11 forwarding through an already opened X11 …\nResize this CryptoVec, appending zeros at the end. This may\nResize this CryptoVec, returning a mutable borrow to the …\nServer side of this library.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nSet a remote environment variable.\nSignal a remote process.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nAwaits an incoming <code>ChannelMsg</code>, this method returns <code>None</code> if …\nInform the server that our window size has changed.\nCreates a new <code>CryptoVec</code> with capacity <code>capacity</code>.\nReturns the min between the maximum packet size and the …\nWrite all this CryptoVec to the provided <code>Write</code>. Returns the\n<code>aes128-cbc</code>\n<code>aes128-ctr</code>\n<code>aes192-cbc</code>\n<code>aes192-ctr</code>\n<code>aes256-cbc</code>\n<code>aes256-ctr</code>\n<code>aes256-gcm@openssh.com</code>\n<code>chacha20-poly1305@openssh.com</code>\n<code>clear</code>\n<code>none</code>\n<code>3des-cbc</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe configuration of clients.\nHandle to a session, used to send messages to a client …\nA client handler. Note that messages can be received from …\nActual client session’s state.\nCalled when this client adjusts the network window. Return …\nWhether to expect and wait for an authentication call.\nCalled when the server sends us an authentication banner. …\nAuthenticate using a custom method that implements the …\nRespond to AuthInfoRequests from the server. A server can …\nInitiate Keyboard-Interactive based SSH authentication.\nPerform no authentication. This is useful for testing, but …\nPerform public OpenSSH Certificate-based SSH authentication\nPerform password-based SSH authentication.\nPerform public key-based SSH authentication.\nRequests cancellation of TCP/IP forwarding from the server\nCalled when the server closes a channel.\nCalled when the server sends EOF to a channel.\nCalled when the server signals failure.\nCalled when the server confirmed our request to open a …\nOpen a TCP/IP forwarding channel. This is usually done …\nCalled when the server rejected our request to open a …\nRequest a session channel (the most basic type of …\nRequest an X11 channel, on which the X11 protocol may be …\nCalled when the server signals success.\nCalled to check the server’s public key. This is a very …\nThe client ID string sent at the beginning of the protocol.\nConnect to a server at the address specified, using the …\nConnect a stream to a server. This stream must implement …\nSend data to the session referenced by this handler.\nCalled when the server sends us data. The <code>extended_code</code> …\nSends a disconnect message.\nCalled when the server sent a disconnect message\nThe remote process exited upon receiving a signal.\nThe remote process has exited, with the given exit status.\nCalled when the server sends us data. The <code>extended_code</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTime after which the connection is garbage-collected.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf nothing is received from the server for this amount of …\nIf this many keepalives have been sent without reply, …\nThe bytes and time limits before key re-exchange.\nThe maximal size of a single packet.\nCalled when the server signals success.\nLists of preferred algorithms.\nReturns the SSH ID (Protocol Version + Software Version) …\nSend a <code>ChannelMsg</code> from the background handler to the …\nCalled when the server gets an unknown channel. It may …\nCalled when the server opens an agent forwarding channel\nCalled when the server opens a direct tcp/ip channel.\nCalled when the server opens a channel for a new remote …\nCalled when the server opens a session channel.\nCalled when the server opens an X11 channel.\nRequests a TCP/IP forwarding from the server\nRequests the server to open a TCP/IP forward channel\nCalled when the network window is adjusted, meaning that we\nThe initial size of a channel (used for flow control).\nThe server informs this client of whether the client may …\nProvide a channel for the reply result to request a reply …\nProvide a channel for the reply result to request a reply …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>curve25519-sha256</code>\n<code>curve25519-sha256@libssh.org</code>\n<code>diffie-hellman-group14-sha1</code>\n<code>diffie-hellman-group14-sha256</code>\n<code>diffie-hellman-group16-sha512</code>\n<code>diffie-hellman-group1-sha1</code>\n<code>ecdh-sha2-nistp256</code>\n<code>ecdh-sha2-nistp384</code>\n<code>ecdh-sha2-nistp521</code>\n<code>kex-strict-c-v00@openssh.com</code>\n<code>kex-strict-s-v00@openssh.com</code>\n<code>ext-info-c</code>\n<code>ext-info-s</code>\n<code>none</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>hmac-sha1</code>\n<code>hmac-sha1-etm@openssh.com</code>\n<code>hmac-sha2-256</code>\n<code>hmac-sha2-256-etm@openssh.com</code>\n<code>hmac-sha2-512</code>\n<code>hmac-sha2-512-etm@openssh.com</code>\n<code>none</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAccept the authentication request.\nAn authentication result, in a challenge-response …\nConfiguration of a server.\nHandle to a session, used to send messages to a client …\nServer handler. Each client will have their own handler.\nThe type of handlers.\nPartially accept the challenge-response authentication …\nReject the authentication request.\nA client’s response in a challenge-response …\nAn active server session returned by run_stream.\nTrait used to create new handlers when clients connect.\nA connected server session. This type is unique to a …\nMethod was not accepted, but no other check was performed.\nCalled when this server adjusts the network window. Return …\nThe client requests OpenSSH agent forwarding\nThe authentication banner, usually a warning message shown …\nCheck authentication using the “keyboard-interactive” …\nCheck authentication using the “none” method. Russh …\nCheck authentication using the “password” method. Russh\nCheck authentication using the “publickey” method. …\nCheck authentication using the “publickey” method. …\nAuthentication rejections must happen in constant time for …\nAuthentication rejection time override for the initial “…\nCalled when authentication succeeds for a session.\nNotifies the client that it can no longer open TCP/IP …\nCancels a previously tcpip_forward request.\nUsed to stop the reverse-forwarding of a port, see RFC4254.\nCalled when the client closes a channel.\nCalled when the client sends EOF to a channel.\nSend a “failure” reply to a global request.\nSend failure to the session referenced by this handler.\nOpens a new agent channel on the client.\nCalled when the client confirmed our request to open a …\nOpens a direct TCP/IP channel on the client.\nOpen a TCP/IP forwarding channel. This is usually done …\nCalled when a new TCP/IP is created. Return value …\nSend a “failure” reply to a request to open a channel …\nOpen a TCP/IP forwarding channel, when a connection comes …\nCalled when a new forwarded connection comes in. …\nOpens a new session channel on the client.\nRequest a session channel (the most basic type of …\nCalled when a new session channel is created. Return value …\nOpen a new X11 channel, when a connection comes to a local …\nCalled when a new X11 channel is created. Return value …\nSend a “success” reply to a channel request. Always …\nSend success to the session referenced by this handler.\nClose a channel.\nClose a channel.\nRetrieves the configuration of this session.\nSend data to a channel. On session channels, <code>extended</code> can …\nSend data to the session referenced by this handler.\nCalled when a data packet is received. A response can be …\nSends a disconnect message.\nAllows a server to disconnect a client session\nThe client wants to set the given environment variable. …\nSend EOF to a channel\nSend EOF to the session referenced by this handler.\nInternal event buffer size\nThe client sends a command to execute, to be passed to a …\nIf the program was killed by a signal, send the details …\nIf the program was killed by a signal, send the details …\nSend the exit status of a program.\nSend the exit status of a program.\nSend data to a channel. On session channels, <code>extended</code> can …\nSend data to the session referenced by this handler.\nCalled when an extended data packet is received. Code 1 …\nFlush the session, i.e. encrypt the pending buffer.\nNotifies the client that it can open TCP/IP forwarding …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a handle to this session.\nReturns a new handle for the session.\nCalled when an active connection fails.\nTime after which the connection is garbage-collected.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf nothing is received from the client for this amount of …\nIf this many keepalives have been sent without reply, …\nPing the client to verify there is still connectivity.\nThe server’s keys. The first key pair in the client’s …\nThe bytes and time limits before key re-exchange.\nMaximal number of allowed authentication attempts.\nThe maximal size of a single packet.\nAuthentication methods proposed to the client.\nCalled when a new client connects.\nLists of preferred algorithms.\nThe client requests a pseudo-terminal with the given …\nReturns the SSH ID (Protocol Version + Software Version) …\nSend a “failure” reply to a global request.\nSend a “success” reply to a /global/ request (requests …\nRun a server. Create a new <code>Connection</code> from the server’s …\nRun a server on a specified <code>tokio::net::TcpListener</code>. …\nRun a single connection to completion.\nThe server ID string sent at the beginning of the protocol.\nThe client requests a shell.\nThe client is sending a signal (usually to pass to the …\nThe client asks to start the subsystem with the given name …\nRequests that the client forward connections to the given …\nUsed for reverse-forwarding ports, see RFC4254. If <code>port</code> is …\nCalled when the network window is adjusted, meaning that we\nThe client’s pseudo-terminal window size has changed.\nThe initial size of a channel (used for flow control).\nThe client requests an X11 connection.\nInform the client of whether they may perform …\nInform the client of whether they may perform …\nInstructions for this challenge.\nName of this challenge.\nA number of prompts to the user. Each prompt has a <code>bool</code> …\nProvide a channel for the reply result to request a reply …\nProvide a channel for the reply result to request a reply …")