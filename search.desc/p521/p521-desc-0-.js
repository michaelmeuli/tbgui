searchState.loadedDescShard("p521", 0, "RustCrypto: NIST P-521 (secp521r1) elliptic curve\nElliptic curve point in affine coordinates.\nCompressed SEC1-encoded NIST P-521 curve point.\nNIST P-521 SEC1 encoded point.\nNIST P-521 field element serialized as bytes.\nNIST P-521 elliptic curve.\nNon-zero NIST P-521 scalar field element.\nMultiplicative identity.\nElliptic curve point in projective coordinates.\nNIST P-521 public key.\nScalars are elements in the finite field modulo <code>n</code>.\nNIST P-521 secret key.\n576-bit unsigned big integer.\nZero element.\nAdd elements.\nDouble element (add it to itself).\nElliptic Curve Diffie-Hellman (Ephemeral) Support.\nElliptic Curve Digital Signature Algorithm (ECDSA)\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Scalar</code> from a canonical big-endian representation.\nDecode <code>Scalar</code> from a big endian byte slice.\nConvert a <code>u64</code> into a <code>Scalar</code>.\nDecode <code>Scalar</code> from <code>U576</code> converting it into Montgomery form:\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCompute <code>Scalar</code> inversion: <code>1 / self</code>.\nDetermine if this <code>Scalar</code> is even in the SEC1 sense: …\nDetermine if this <code>Scalar</code> is odd in the SEC1 sense: …\nDetermine if this <code>Scalar</code> is zero.\nMultiply elements.\nNegate element.\nReturns <code>self^exp</code>, where <code>exp</code> is a little-endian integer …\nRight shifts the scalar.\nCompute modular square root.\nCompute modular square.\nSubtract elements.\nReturns the big-endian encoding of this <code>Scalar</code>.\nTranslate <code>Scalar</code> out of the Montgomery domain, returning a …\nNIST P-521 Ephemeral Diffie-Hellman Secret.\nShared secret value computed via ECDH key agreement.\nLow-level Elliptic Curve Diffie-Hellman (ECDH) function.\nECDSA/P-521 signature (ASN.1 DER encoded)\nContains the error value\nSignature errors.\nContains the success value\nResult type.\nECDSA/P-521 signature (fixed-size)\nECDSA/P-521 signing key\nECDSA/P-521 verification key (i.e. public key)\nBorrow the inner <code>AffinePoint</code> for this public key.\nBorrow the secret <code>NonZeroScalar</code> value for this key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize <code>VerifyingKey</code> from an affine point.\nInitialize signing key from a raw scalar serialized as a …\nInitialize <code>VerifyingKey</code> from an <code>EncodedPoint</code>.\nInitialize <code>VerifyingKey</code> from a SEC1-encoded public key.\nInitialize signing key from a raw scalar serialized as a …\nCreate a new error with an associated source.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new error with no associated source\nGenerate a cryptographically random <code>SigningKey</code>.\nSerialize this <code>SigningKey</code> as bytes\nSerialize this <code>VerifyingKey</code> as a SEC1 <code>EncodedPoint</code>, …")