searchState.loadedDescShard("ssh_key", 0, "RustCrypto: SSH Keys and Certificates\nAES-128 in cipher block chaining (CBC) mode.\nAES-128 in counter (CTR) mode.\nAES-128 in Galois/Counter Mode (GCM).\nAES-192 in cipher block chaining (CBC) mode.\nAES-192 in counter (CTR) mode.\nAES-256 in cipher block chaining (CBC) mode.\nAES-256 in counter (CTR) mode.\nAES-256 in Galois/Counter Mode (GCM).\nSSH key algorithms.\nA string representing an additional algorithm name in the …\nUnknown algorithm.\nUnsupported algorithm.\nbcrypt-pbkdf.\nbcrypt-pbkdf options.\nCarriage return: <code>\\r</code> (Pre-OS X Macintosh)\nCarriage return + line feed: <code>\\r\\n</code> (Windows)\nCertificate field is invalid or already set.\nCertificate validation failed.\nChaCha20-Poly1305\nCipher algorithms.\nCryptographic errors.\nCannot perform operation on decrypted private key.\nDigital Signature Algorithm\nElliptic Curve Digital Signature Algorithm\nECDSA key encoding errors.\nElliptic curves supported for use with ECDSA.\nEd25519\nEncoding errors.\nCannot perform operation on encrypted private key.\nContains the error value\nError type.\nSSH public key fingerprints.\nOther format encoding errors.\nHashing algorithms a.k.a. digest functions.\nInput/output errors.\nKey Derivation Functions (KDF).\nKey Derivation Function (KDF) algorithms.\nLine feed: <code>\\n</code> (Unix OSes)\nLine endings: variants of newline characters that can be …\nMultiple precision integer, a.k.a. “mpint”.\nNamespace invalid.\nNIST P-256 (a.k.a. prime256v1, secp256r1)\nNIST P-384 (a.k.a. secp384r1)\nNIST P-521 (a.k.a. secp521r1)\nNo cipher.\nNone.\nNo KDF.\nContains the success value\nOther\nPublic key is incorrect.\nResult type with <code>ssh-key</code>’s <code>Error</code> as the error type.\nRSA\nSHA-256\nFingerprints computed using SHA-256.\nSHA-512\nFingerprints computed using SHA-512.\nLow-level digital signature (e.g. DSA, ECDSA, Ed25519).\nTrait for signing keys which produce a <code>Signature</code>.\nFIDO/U2F key with ECDSA/NIST-P256 + SHA-256\nFIDO/U2F key with Ed25519\n<code>sshsig</code> provides a general-purpose signature format based …\nTripleDES in block chaining (CBC) mode\nInvalid timestamp (e.g. in a certificate)\nUnexpected trailing data at end of message.\nSupported version.\nUnsupported version.\nGet the hash algorithm used for this fingerprint.\nGet the KDF algorithm.\nGet the <code>Algorithm</code> associated with this signature.\nGet the signature algorithm.\nGet the byte serialization of this <code>LineEnding</code>.\nGet the raw digest output for the fingerprint as bytes.\nGet the big integer data encoded as big endian bytes.\nGet the raw signature as bytes.\nGet the bytes of a positive integer.\nGet the string identifier which corresponds to this …\nGet the string identifier which corresponds to this …\nGet the string identifier which corresponds to this …\nGet the string identifier which corresponds to this ECDSA …\nGet the string identifier for this hash algorithm.\nGet the string identifier which corresponds to this …\nParser for <code>AuthorizedKeysFile</code>-formatted data.\nGet the block size for this cipher in bytes.\nOpenSSH certificate support.\nGet the string identifier which corresponds to the OpenSSH …\nDecrypt the ciphertext in the <code>buffer</code> in-place using this …\nDerive an encryption key from the given password.\nDerive key and IV for the given <code>Cipher</code>.\nCompute a digest of the given message using this hash …\nGet the size of a digest produced by this hash function.\nEncrypt the ciphertext in the <code>buffer</code> in-place using this …\nFormat “randomart” for this fingerprint using the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new multiple precision integer from the given big …\nCreate a new <code>AlgorithmName</code> from an OpenSSH certificate …\nDecode signature from PEM which begins with the following:\nCreate a new multiple precision integer from the given big …\nDoes this cipher have an authentication tag? (i.e. is it …\nGet the hash algorithm used to produce this signature.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the KDF configured as <code>bcrypt</code> (i.e. bcrypt-pbkdf)?\nIs the algorithm DSA?\nIs the algorithm ECDSA?\nIs the algorithm Ed25519?\nIs this cipher <code>none</code>?\nIs the KDF algorithm “none”?\nIs the KDF configured as <code>none</code>?\nIs the algorithm RSA?\nIs this fingerprint SHA-256?\nIs this fingerprint SHA-512?\nIs the cipher anything other than <code>none</code>?\nIs the KDF configured as anything other than <code>none</code>?\nGet the key and IV size for this cipher in bytes.\nParser for <code>KnownHostsFile</code>-formatted data.\nGet the encoded length of this <code>LineEnding</code>.\nGet the namespace (i.e. domain identifier) for this …\nDecode cipher algorithm from the given <code>ciphername</code>.\nCreate a new algorithm identifier.\nDecode algorithm from the given string identifier.\nDecode elliptic curve from the given string identifier.\nDecode elliptic curve from the given string identifier.\nDecode KDF algorithm from the given <code>kdfname</code>.\nCreate a fingerprint of the given public key data using …\nInitialize KDF configuration for the given algorithm.\nCreate a new signature with the given algorithm and raw …\nCreate a new signature with the given public key, …\nDecode algorithm from the given string identifier as used …\nCompute the length of padding necessary to pad the given …\nGet the name of the hash algorithm (upper case e.g. “…\nSSH private key support.\nSSH public key support.\nGet the <code>public::KeyData</code> for this signing key.\nGet public key which corresponds to the signing key that …\nGet reserved data associated with this signature. …\nGet the SHA-256 fingerprint, if this is one.\nGet the SHA-512 fingerprint, if this is one.\nSign the given message with the provided signing key.\nGet the structured signature over the given message.\nGet the bytes which comprise the serialized signature.\nGet the raw message over which the signature for a given …\nGet the string identifier which corresponds to the OpenSSH …\nEncode signature as PEM which begins with the following:\nRender “randomart” hash visualization for this …\nGet version number for this signature.\nElliptic curve with which to instantiate ECDSA.\nHash function to use with RSASSA-PKCS#1v15 signatures as …\nAlgorithm identifier.\nVersion number.\nNumber of bytes of remaining data at end of message.\nRounds\nSalt\nParser for <code>AuthorizedKeysFile</code>-formatted data, typically …\nConfiguration options associated with a particular public …\nIterator over configuration options.\nIndividual entry in an <code>authorized_keys</code> file containing a …\nBorrow the configuration options as a <code>str</code>.\nGet configuration options for this entry.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre there no configuration options?\nIterate over the comma-delimited configuration options.\nCreate a new parser for the given input buffer.\nParse an options string.\nCreate new configuration options iterator.\nGet public key for this entry.\nRead an <code>AuthorizedKeys</code> file from the filesystem, returning …\nOpenSSH certificate builder.\nTypes of OpenSSH certificates: user or host.\nOpenSSH certificate as specified in PROTOCOL.certkeys.\nComment\nCritical options\nExtensions\nCertificate fields.\nHost certificate\nKey ID\nNonce\nKey/value map type used for certificate’s critical …\nSubject public key\nRecommended size for a nonce.\nSerial number\nSignature\nSignature key (i.e. CA key)\nCertificate type: user or host\nUser certificate\nValid after (Unix time)\nValid before (Unix time)\nValid principals\nGet the public key algorithm for this certificate.\nMark this certificate as being valid for all principals.\nGet the field name as a string\nSet certificate type: user or host.\nSpecifies whether this certificate is for identification …\nAdd a comment to this certificate.\nGet the comment on this certificate.\nAdd a critical option to this certificate.\nThe critical options section of the certificate specifies …\nAdd an extension to this certificate.\nThe extensions section of the certificate specifies zero …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a raw binary OpenSSH certificate.\nParse an OpenSSH-formatted certificate.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet an <code>Error</code> that this field is invalid.\nIs this a host certificate?\nIs this a user certificate?\nSet key ID: label to identify this particular certificate.\nKey IDs are a free-form text field that is filled in by …\nCreate a new certificate builder for the given subject’s …\nCreate a new <code>OptionsMap</code>.\nCreate a new certificate builder, generating a random …\nCreate a new certificate builder with the validity window …\nNonces are a CA-provided random bitstring of arbitrary …\nGet this certificate’s public key data.\nRead OpenSSH certificate from a file.\nSet certificate serial number.\nOptional certificate serial number set by the CA to …\nSign the certificate using the provided signer type.\nSignature computed over all preceding fields from the …\nSignature key of signing CA.\nSerialize OpenSSH certificate as raw bytes.\nEncode OpenSSH certificate to a <code>String</code>.\nValid after (Unix time).\nValid after (system time).\nValid before (Unix time).\nValid before (system time).\nAdd a principal (i.e. username or hostname) to …\nList of zero or more principals which this certificate is …\nPerform certificate validation using the system clock to …\nPerform certificate validation.\nWrite OpenSSH certificate to a file.\nThis host entry’s public key is for a certificate …\nIndividual entry in an <code>known_hosts</code> file containing a …\nA single hashed hostname\nThe host pattern(s) for this host entry.\nParser for <code>KnownHostsFile</code>-formatted data, typically found …\nMarkers associated with this host key entry.\nA comma separated list of hostname patterns.\nThis host entry’s public key has been revoked, and …\nGet the string form of the marker\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the host pattern enumerator for this entry\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the marker for this entry, if present.\nCreate a new parser for the given input buffer.\nGet public key for this entry.\nRead a <code>KnownHosts</code> file from the filesystem, returning an …\nAn SHA-1 hash of the hostname along with the salt\nThe salt used for the hash\nSize of an Ed25519 private key in bytes.\nSize of an Ed25519 keypair in bytes.\nDigital Signature Algorithm (DSA) keypair.\nDigital Signature Algorithm (DSA) private/public keypair.\nDigital Signature Algorithm (DSA) private key.\nECDSA keypair.\nElliptic Curve Digital Signature Algorithm (ECDSA) …\nElliptic Curve Digital Signature Algorithm (ECDSA) private …\nEd25519 keypair.\nEd25519 private/public keypair.\nEd25519 private key.\nEncrypted private key (ciphertext).\nPrivate key data: digital signature key pairs.\nNIST P-256 ECDSA keypair.\nNIST P-384 ECDSA keypair.\nNIST P-521 ECDSA keypair.\nAn opaque keypair.\nThe underlying representation of an <code>OpaqueKeypair</code>.\nAn opaque private key.\nOpaque keypair.\nSSH private key.\nRSA keypair.\nRSA private/public keypair.\nRSA private key.\nSecurity Key (FIDO/U2F) ECDSA/NIST P-256 private key as …\nSecurity Key (FIDO/U2F) using ECDSA/NIST P-256 as …\nSecurity Key (FIDO/U2F) Ed25519 private key as specified in\nSecurity Key (FIDO/U2F) using Ed25519 as specified in …\nGet the <code>Algorithm</code> for this public key type.\nGet the <code>Algorithm</code> for this private key.\nGet the <code>Algorithm</code> for this key type.\nGet the digital signature <code>Algorithm</code> used by this key.\nGet the serialized private key as bytes.\nGet the inner <code>Mpint</code>.\nBorrow the inner byte array as a slice.\nCipher algorithm (a.k.a. <code>ciphername</code>).\nComment on the key (e.g. email address).\nGet the <code>EcdsaCurve</code> for this key.\nRSA private exponent.\nDecode <code>KeypairData</code> for the specified algorithm.\nAttempt to decrypt an encrypted private key using the …\nGet DSA keypair if this key is the correct type.\nGet ECDSA private key if this key is the correct type.\nGet Ed25519 private key if this key is the correct type.\nEncode OpenSSH-formatted (PEM) private key.\nEncrypt an unencrypted private key using the provided …\nEncrypt an unencrypted private key using the provided …\nEncrypt an unencrypted private key using the provided …\nGet the encrypted ciphertext if this key is encrypted.\nCompute key fingerprint.\nGet flags.\nGet flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse Ed25519 private key from bytes.\nParse Ed25519 keypair from 64-bytes which comprise the …\nParse a raw binary SSH private key.\nParse an OpenSSH-formatted PEM private key.\nExpand a keypair from a 32-byte seed value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert to the inner byte array.\nCRT coefficient: <code>(inverse of q) mod p</code>.\nIs this key a DSA key?\nIs this key an ECDSA key?\nIs this key an Ed25519 key?\nIs this key encrypted?\nIs this key encrypted?\nIs this a key with a custom algorithm?\nIs this key an RSA key?\nIs this key a FIDO/U2F ECDSA/NIST P-256 key?\nIs this key a FIDO/U2F Ed25519 key?\nKey Derivation Function (KDF) used to encrypt this key.\nKeypair data.\nGet FIDO/U2F key handle.\nGet FIDO/U2F key handle.\nCreate a new <code>OpaqueKeypair</code>.\nConstruct new instance of SkEcdsaSha2NistP256.\nConstruct new instance of SkEd25519.\nCreate a new unencrypted private key with the given …\nGet the custom, opaque private key if this key is the …\nFirst prime factor of <code>n</code>.\nThe opaque private key\nPrivate key.\nPrivate key.\nThe opaque private key\nPrivate key.\nGet the bytes representing the private key.\nGet the ECDSA/NIST P-256 public key.\nGet the Ed25519 public key.\nThe opaque public key\nPublic key.\nPublic key.\nThe opaque public key\nPublic key.\nGet the <code>PublicKey</code> which corresponds to this private key.\nGet the bytes representing the public key.\nSecond prime factor of <code>n</code>.\nGenerate a random ECDSA private key.\nGenerate a random Ed25519 private key.\nGenerate a random Ed25519 private keypair.\nGenerate a random RSA keypair of the given size.\nGenerate a random key which uses the given algorithm.\nRead private key from an OpenSSH-formatted PEM file.\nGet RSA keypair if this key is the correct type.\nSet the comment on the key.\nSign the given message using this private key, returning …\nGet FIDO/U2F ECDSA/NIST P-256 private key if this key is …\nGet FIDO/U2F Ed25519 private key if this key is the …\nConvert to the inner byte array.\nSerialize an Ed25519 keypair as bytes.\nSerialize SSH private key as raw bytes.\nEncode an OpenSSH-formatted PEM private key, allocating a …\nWrite private key as an OpenSSH-formatted PEM file.\nPrivate key.\nPrivate key.\nPrivate key.\nPublic key.\nPublic key.\nPublic key.\nSize of an Ed25519 public key in bytes.\nDigital Signature Algorithm (DSA) public key data.\nDigital Signature Algorithm (DSA) public key.\nElliptic Curve Digital Signature Algorithm (ECDSA) public …\nElliptic Curve Digital Signature Algorithm (ECDSA) public …\nEd25519 public key data.\nEd25519 public key.\nPublic key data.\nNIST P-256 ECDSA public key.\nNIST P-384 ECDSA public key.\nNIST P-521 ECDSA public key.\nAn opaque public key with a custom algorithm name.\nThe underlying representation of an <code>OpaquePublicKey</code>.\nOpaque public key data.\nSSH public key.\nRSA public key data.\nRSA public key.\nSecurity Key (FIDO/U2F) ECDSA/NIST P-256 public key as …\nSecurity Key (FIDO/U2F) using ECDSA/NIST P-256 as …\nSecurity Key (FIDO/U2F) Ed25519 public key as specified in …\nSecurity Key (FIDO/U2F) using Ed25519 as specified in …\nGet the <code>Algorithm</code> for this public key type.\nGet the <code>Algorithm</code> for this public key.\nGet the <code>Algorithm</code> for this public key type.\nGet the digital signature <code>Algorithm</code> used by this key.\nThe <code>Algorithm</code> of this public key.\nGet the FIDO/U2F application (typically <code>ssh:</code>).\nGet the FIDO/U2F application (typically <code>ssh:</code>).\nBorrow the SEC1-encoded key data as bytes.\nComment on the key (e.g. email address).\nGet the <code>EcdsaCurve</code> for this key.\nGet DSA public key if this key is the correct type.\nRSA public exponent.\nGet the elliptic curve point for this Security Key.\nGet ECDSA public key if this key is the correct type.\nGet Ed25519 public key if this key is the correct type.\nEncode OpenSSH-formatted public key.\nCompute key fingerprint.\nCompute key fingerprint.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a raw binary SSH public key.\nParse an OpenSSH-formatted public key.\nParse an ECDSA public key from a SEC1-encoded point.\nGenerator of a subgroup of order <code>q</code> in the multiplicative …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this key a DSA key?\nIs this key an ECDSA key?\nIs this key an Ed25519 key?\nIs this a key with a custom algorithm?\nIs this key an RSA key?\nIs this key a FIDO/U2F ECDSA/NIST P-256 key?\nIs this key a FIDO/U2F Ed25519 key?\nThe key data\nPublic key data.\nRSA modulus.\nCreate a new <code>OpaquePublicKey</code>.\nConstruct new instance of SkEcdsaSha2NistP256.\nConstruct new instance of SkEd25519.\nCreate a new public key with the given comment.\nGet the custom, opaque public key if this key is the …\nPrime modulus.\nGet the Ed25519 private key for this security key.\nPrime divisor of <code>p - 1</code>.\nRead public key from an OpenSSH-formatted file.\nGet RSA public key if this key is the correct type.\nSet the comment on the key.\nGet FIDO/U2F ECDSA/NIST P-256 public key if this key is …\nGet FIDO/U2F Ed25519 public key if this key is the correct …\nSerialize SSH public key as raw bytes.\nEncode an OpenSSH-formatted public key, allocating a <code>String</code>…\nVerify the <code>SshSig</code> signature over the given message using …\nWrite public key as an OpenSSH-formatted file.\nThe public key, where <code>y = gˣ mod p</code>.")