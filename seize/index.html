<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Seize"><title>seize - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="seize" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../seize/index.html">seize</a><span class="version">0.3.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#seize" title="Seize">Seize</a></li><li><a href="#introduction" title="Introduction">Introduction</a></li><li><a href="#details" title="Details">Details</a></li><li><a href="#guide" title="Guide">Guide</a><ul><li><a href="#collectors" title="Collectors">Collectors</a></li><li><a href="#allocating-objects" title="Allocating Objects">Allocating Objects</a></li><li><a href="#starting-operations" title="Starting Operations">Starting Operations</a></li><li><a href="#protecting-pointers" title="Protecting Pointers">Protecting Pointers</a></li><li><a href="#retiring-objects" title="Retiring Objects">Retiring Objects</a></li><li><a href="#dst-support" title="DST Support">DST Support</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>seize</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/seize/lib.rs.html#1-11">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="seize"><a class="doc-anchor" href="#seize">§</a>Seize</h2>
<p><a href="https://crates.io/crates/seize"><img src="https://img.shields.io/crates/v/seize?style=for-the-badge" alt="Crate" /></a>
<a href="https://github.com/ibraheemdev/seize"><img src="https://img.shields.io/badge/github-seize-success?style=for-the-badge" alt="Github" /></a>
<a href="https://docs.rs/seize"><img src="https://img.shields.io/badge/docs.rs-0.3.3-4d76ae?style=for-the-badge" alt="Docs" /></a></p>
<p>Fast, efficient, and robust memory reclamation for concurrent data structures.</p>
<h2 id="introduction"><a class="doc-anchor" href="#introduction">§</a>Introduction</h2>
<p>Concurrent data structures are faced with the problem of deciding when it is
safe to free memory. Although an object might have been logically removed, other
threads that previously loaded it may still be accessing it, and thus it is
not safe to free immediately. Over the years, many algorithms have been devised
to solve this problem. However, most traditional memory reclamation schemes make
the tradeoff between performance, efficiency, and robustness. For example,
<a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">epoch based reclamation</a> is fast and lightweight but lacks robustness in that a
stalled thread can prevent the reclamation of <em>all</em> retired objects. <a href="https://www.cs.otago.ac.nz/cosc440/readings/hazard-pointers.pdf">Hazard
pointers</a>, another popular scheme, tracks individual pointers, making it efficient
and robust but generally much slower.</p>
<p>Another problem that is often not considered is workload balancing. In most
reclamation schemes, the thread that retires an object is the one that reclaims
it. This leads to unbalanced reclamation in read-dominated workloads;
parallelism is degraded when only a fraction of threads are writing. This is
especially prevalent with the use of M:N threading models as provided by
asynchronous runtimes like <a href="https://github.com/tokio-rs/tokio">Tokio</a>.</p>
<h2 id="details"><a class="doc-anchor" href="#details">§</a>Details</h2>
<p>Seize is based on the <a href="https://arxiv.org/pdf/1905.07903.pdf">hyaline reclamation scheme</a>, which uses reference counting
to determine when it is safe to free memory. However, reference counters are only
used for objects that have been retired, allowing it to avoid the high overhead
incurred by traditional reference counting schemes where every memory access requires
modifying shared memory. Performance is competitive with that of epoch based schemes,
while memory efficiency is similar to hazard pointers. Reclamation is naturally
balanced as the thread with the last reference to an object is the one that frees it.
Epochs can also be optionally tracked to protect against stalled threads, making reclamation
truly lock-free.</p>
<p>Seize is compatible with all modern hardware that supports single-word atomic
operations such as FAA and CAS.</p>
<h2 id="guide"><a class="doc-anchor" href="#guide">§</a>Guide</h2>
<p>Seize tries to stay out of your way as much as possible. It works with raw
pointers directly instead of creating safe wrapper types that end up being a
hassle to work with in practice. Below is a step-by-step guide on how to get
started.</p>
<h4 id="collectors"><a class="doc-anchor" href="#collectors">§</a>Collectors</h4>
<p>Seize avoids the use of global state and encourages creating a designated
<em>collector</em> per data structure. Collectors allow you to allocate, protect, and
retire objects:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>seize::Collector;

<span class="kw">struct </span>Stack&lt;T&gt; {
    collector: Collector,
    <span class="comment">// ...
</span>}

<span class="kw">impl</span>&lt;T&gt; Stack&lt;T&gt; {
    <span class="kw">pub fn </span>new() -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{
            collector: Collector::new(),
        }
    }
}</code></pre></div>
<h4 id="allocating-objects"><a class="doc-anchor" href="#allocating-objects">§</a>Allocating Objects</h4>
<p>Seize requires storing some metadata about the global epoch for each object that
is allocated. It also needs to reserve a couple words for retirement lists.
Because of this, objects in a concurrent data structure that may be reclaimed must
embed the <code>Link</code> type or use the <code>Linked&lt;T&gt;</code> wrapper provided for convenience. See
<a href="#dst-support">DST Support</a> for more details.</p>
<p>You can create a <code>Link</code> with the <code>link</code> method, or allocate and link a value with
the <code>link_boxed</code> helper:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>seize::{reclaim, Collector, Linked};
<span class="kw">use </span>std::mem::ManuallyDrop;
<span class="kw">use </span>std::sync::atomic::{AtomicPtr, Ordering};

<span class="kw">pub struct </span>Stack&lt;T&gt; {
    head: AtomicPtr&lt;Linked&lt;Node&lt;T&gt;&gt;&gt;, <span class="comment">// &lt;===
    </span>collector: Collector,
}

<span class="kw">struct </span>Node&lt;T&gt; {
    next: <span class="kw-2">*mut </span>Linked&lt;Node&lt;T&gt;&gt;, <span class="comment">// &lt;===
    </span>value: ManuallyDrop&lt;T&gt;,
}

<span class="kw">impl</span>&lt;T&gt; Stack&lt;T&gt; {
    <span class="kw">pub fn </span>push(<span class="kw-2">&amp;</span><span class="self">self</span>, value: T) {
        <span class="kw">let </span>node = <span class="self">self</span>.collector.link_boxed(Node { <span class="comment">// &lt;===
            </span>next: std::ptr::null_mut(),
            value: ManuallyDrop::new(value),
        });

        <span class="comment">// ...
    </span>}
}</code></pre></div>
<h4 id="starting-operations"><a class="doc-anchor" href="#starting-operations">§</a>Starting Operations</h4>
<p>Before starting an operation that involves loading atomic pointers, you must
mark the thread as <em>active</em> by calling the <code>enter</code> method.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>Stack {
    <span class="kw">pub fn </span>push(<span class="kw-2">&amp;</span><span class="self">self</span>, value: T) {
        <span class="comment">// ...

        </span><span class="kw">let </span>guard = <span class="self">self</span>.collector.enter(); <span class="comment">// &lt;===

        // ...
    </span>}
}</code></pre></div>
<h4 id="protecting-pointers"><a class="doc-anchor" href="#protecting-pointers">§</a>Protecting Pointers</h4>
<p><code>enter</code> returns a guard that allows you to safely load atomic pointers. Any
valid pointer loaded through a guard is guaranteed to stay valid until the
guard is dropped, or is retired by the current thread. Importantly, if another
thread retires an object that you protected, the collector knows not to reclaim
the object until your guard is dropped.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>Stack {
    <span class="kw">pub fn </span>push(<span class="kw-2">&amp;</span><span class="self">self</span>, value: T) {
        <span class="comment">// ...

        </span><span class="kw">let </span>guard = <span class="self">self</span>.collector.enter();

        <span class="kw">loop </span>{
            <span class="kw">let </span>head = guard.protect(<span class="kw-2">&amp;</span><span class="self">self</span>.head, Ordering::Acquire); <span class="comment">// &lt;===
            </span><span class="kw">unsafe </span>{ (<span class="kw-2">*</span>node).next = head; }

            <span class="kw">if </span><span class="self">self
                </span>.head
                .compare_exchange(head, node, Ordering::Release, Ordering::Relaxed)
                .is_ok()
            {
                <span class="kw">break</span>;
            }
        }

        <span class="comment">// drop(guard);
    </span>}
}</code></pre></div>
<p>Note that the lifetime of a guarded pointer is logically tied to that of the
guard – when the guard is dropped the pointer is invalidated – but a raw
pointer is returned for convenience. Datastructures that return shared references
to values should ensure that the lifetime of the reference is tied to the lifetime
of a guard.</p>
<h4 id="retiring-objects"><a class="doc-anchor" href="#retiring-objects">§</a>Retiring Objects</h4>
<p>Objects that have been removed from a data structure can be safely <em>retired</em>
through the collector. It will be <em>reclaimed</em> when no threads holds a reference
to it:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;T&gt; Stack&lt;T&gt; {
    <span class="kw">pub fn </span>pop(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;T&gt; {
        <span class="kw">let </span>guard = <span class="self">self</span>.collector.enter(); <span class="comment">// &lt;=== mark the thread as active

        </span><span class="kw">loop </span>{
            <span class="kw">let </span>head = guard.protect(<span class="kw-2">&amp;</span><span class="self">self</span>.head, Ordering::Acquire); <span class="comment">// &lt;=== safely load the head

            </span><span class="kw">if </span>head.is_null() {
                <span class="kw">return </span><span class="prelude-val">None</span>;
            }

            <span class="kw">let </span>next = <span class="kw">unsafe </span>{ (<span class="kw-2">*</span>head).next };

            <span class="kw">if </span><span class="self">self
                </span>.head
                .compare_exchange(head, next, Ordering::Release, Ordering::Relaxed)
                .is_ok()
            {
                <span class="kw">unsafe </span>{
                    <span class="kw">let </span>data = ptr::read(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span>head).value);
                    <span class="self">self</span>.collector.retire(head, reclaim::boxed::&lt;Linked&lt;Node&lt;T&gt;&gt;&gt;); <span class="comment">// &lt;===
                    </span><span class="kw">return </span><span class="prelude-val">Some</span>(ManuallyDrop::into_inner(data));
                }
            }
        }
    }
}</code></pre></div>
<p>There are a couple important things to note about retiring an object:</p>
<h5 id="retired-objects-must-be-logically-removed"><a class="doc-anchor" href="#retired-objects-must-be-logically-removed">§</a>Retired objects must be logically removed</h5>
<p>An object can only be retired if it is <em>no longer accessible</em> to any thread that
comes after. In the above code example this was ensured by swapping out the node
before retiring it. Threads that loaded a value <em>before</em> it was retired are
safe, but threads that come after are not.</p>
<h5 id="retired-objects-cannot-be-accessed-by-the-current-thread"><a class="doc-anchor" href="#retired-objects-cannot-be-accessed-by-the-current-thread">§</a>Retired objects cannot be accessed by the current thread</h5>
<p>Unlike in schemes like EBR, a guard does not protect objects retired by the
current thread. If no other thread holds a reference to an object it may be
reclaimed <em>immediately</em>. This makes the following code unsound:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr = guard.protect(<span class="kw-2">&amp;</span>node, Ordering::Acquire);
collector.retire(ptr, |<span class="kw">_</span>| {});
<span class="macro">println!</span>(<span class="string">"{}"</span>, (<span class="kw-2">*</span>ptr).value); <span class="comment">// &lt;===== unsound!</span></code></pre></div>
<p>Retirement can be delayed until the guard is dropped by calling <code>defer_retire</code> on
the guard, instead of on the collector directly:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr = guard.protect(<span class="kw-2">&amp;</span>node, Ordering::Acquire);
guard.defer_retire(ptr, |<span class="kw">_</span>| {});
<span class="macro">println!</span>(<span class="string">"{}"</span>, (<span class="kw-2">*</span>ptr).value); <span class="comment">// &lt;===== ok!
</span>drop(guard); <span class="comment">// &lt;===== ptr is invalidated</span></code></pre></div>
<h5 id="custom-reclaimers"><a class="doc-anchor" href="#custom-reclaimers">§</a>Custom Reclaimers</h5>
<p>You probably noticed that <code>retire</code> takes a function as a second parameter. This
function is known as a <em>reclaimer</em>, and is run when the collector decides it is
safe to free the retired object. Typically you will pass in a function from the
<a href="https://docs.rs/seize/latest/seize/reclaim/index.html"><code>seize::reclaim</code></a> module.
For example, values allocated with <code>Box</code> can use <code>reclaim::boxed</code>:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>seize::reclaim;

<span class="kw">impl</span>&lt;T&gt; Stack&lt;T&gt; {
    <span class="kw">pub fn </span>pop(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;T&gt; {
        <span class="comment">// ...
        </span><span class="self">self</span>.collector.retire(head, reclaim::boxed::&lt;Linked&lt;Node&lt;T&gt;&gt;); <span class="comment">// &lt;===
        // ...
    </span>}
}</code></pre></div>
<p>The type annotation there is important. It is <strong>unsound</strong> to pass a reclaimer of
a different type than the object being retired.</p>
<p>If you need to run custom reclamation code, you can write a custom reclaimer.
Functions passed to <code>retire</code> are called with a type-erased <code>Link</code> pointer. This is
because retired values are connected to thread-local batches via linked lists,
losing any type information. To extract the underlying value from a link, you can
call the <code>cast</code> method:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>collector.retire(value, |link: <span class="kw-2">*mut </span>Link| <span class="kw">unsafe </span>{
    <span class="comment">// SAFETY: the value retired was of type *mut Linked&lt;T&gt;
    </span><span class="kw">let </span>ptr: <span class="kw-2">*mut </span>Linked&lt;T&gt; = Link::cast(link);

    <span class="comment">// SAFETY: the value was allocated with `link_boxed`
    </span><span class="kw">let </span>value = Box::from_raw(ptr);
    <span class="macro">println!</span>(<span class="string">"dropping {}"</span>, value);
    drop(value);
});</code></pre></div>
<h4 id="dst-support"><a class="doc-anchor" href="#dst-support">§</a>DST Support</h4>
<p>Most reclamation use cases can work with <code>Linked&lt;T&gt;</code> and avoid working with
links directly. However, advanced use cases such as dynamically sized types
may requie more control over type layout. To support this, seize allows embedding
a <code>Link</code> directly in your type. See the <a href="https://docs.rs/seize/latest/seize/trait.AsLink.html"><code>AsLink</code></a>
trait for more details.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="reclaim/index.html" title="mod seize::reclaim">reclaim</a></div><div class="desc docblock-short">Common memory reclaimers.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Collector.html" title="struct seize::Collector">Collector</a></div><div class="desc docblock-short">Fast, efficient, and robust memory reclamation.</div></li><li><div class="item-name"><a class="struct" href="struct.Guard.html" title="struct seize::Guard">Guard</a></div><div class="desc docblock-short">A guard that keeps the current thread marked as active,
enabling protected loads of atomic pointers.</div></li><li><div class="item-name"><a class="struct" href="struct.Link.html" title="struct seize::Link">Link</a></div><div class="desc docblock-short">A link to the collector.</div></li><li><div class="item-name"><a class="struct" href="struct.Linked.html" title="struct seize::Linked">Linked</a></div><div class="desc docblock-short">A value <a href="struct.Collector.html#method.link" title="method seize::Collector::link">linked</a> to a collector.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AsLink.html" title="trait seize::AsLink">AsLink</a></div><div class="desc docblock-short">A type that can be pointer-cast to and from a <a href="struct.Link.html" title="struct seize::Link"><code>Link</code></a>.</div></li></ul></section></div></main></body></html>